### Format Strings and Templates

Producing results can be complicated. Almost all programming languages have special mechanisms to make output easier; even the original 1956 version of FORTRAN did ([*The FORTRAN Automatic Coding System for IBM 704 EDPM: Programmer’s Reference Manual*](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf), 1956)! These mechanisms include various kinds of format string and template systems. These mechanisms can be very powerful and speed development. They can also be critical for countering vulnerabilities; one of the best ways to counter the Cross-Site Scripting (XSS) attacks is to use a templating system that counters it by default, as we have already discussed.

However, *be very careful* about letting untrusted users control the output formats (that is, using format strings and templates from untrusted users). In many cases, you should *not* let untrusted users set output formats that are used by general-purpose templating systems without carefully validating them first. Some output format systems can execute arbitrary code, or reveal information beyond a specific set of approved values - and you *definitely* should not allow that in most cases! Even when they cannot run *arbitrary* code, by definition they control the output, and they may be able to create misleading results or results that overwhelm wherever the output goes.

The C programming language output routines are especially dangerous, because their design assumes that the format string parameters are from trusted sources. For example, the **printf()** family of routines (including **fprintf** and **snprintf**) takes a *format string* parameter; if an attacker can control the format string, then the attacker can trivially make the result arbitrarily long (leading to a buffer overflow), print any memory area (revealing confidential information or data that enables a security bypass), or use the **%n** operation to overwrite arbitrary memory areas. The same is true for **syslog()** (which writes system log information) and **setproctitle()** (which sets the string used to display process identifier information). Many functions with names beginning with “**err**” or “**warn**”, containing “**log**”, or ending in “**printf**” are worth reviewing.

Most other programming languages’ format systems are not quite that dangerous, but they can still cause problems. The best solution is to make sure that an untrusted user cannot provide the format string. If circumstances require that you allow that, *make sure* that the system you use cannot allow a vulnerability, e.g., by only allowing specific kinds of formats (be sure to validate that!), or use a library that is specifically designed to be safely used with untrusted templates. Even in those cases, remember that if a user can control the output template, the user can produce a copious amount of output. Ensure that this is not a serious issue (e.g., by ensuring that only that same user sees the results from that template, so attackers only end up attacking themselves).

Many output formatting systems have a way to support internationalization (**i18n**) and localization (**l10n**). The widely-used **gettext()** system, for example, lets you select a string (including a format string or template) using the user’s current locale. The value of the locale would typically be provided by an untrusted user. However, that is okay as long as its only effect is to select between format strings or templates, all of which you know you can trust.
